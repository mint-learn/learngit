
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "book_management.h"

/*You can extend the structs (Book and BookArray) defined in this head file;
  However, you may not change the function prototypes. 
  You are also free to add additional head files and data structures as needed. 


extern 	struct Book* head_book; 
typedef enum __bool { false = 0, true = 1, } bool;*/

void insert_book(Book *head_book, Book *r){
	int i, id, flag = 1;
	Book *p, *q;

	while (id != 0) {
		r = (Book *)malloc(sizeof(Book));
		/*r->next = NULL;
		r->id = id;
		printf("Please input book's title, authors, year, copies\n");
		scanf("%s, %s, %d, %d", &r->title, &r->authors, &r->year, &r->copies);*/
		q = head_book;
		p = head_book->next;
		while (q->next != NULL){
			p = p->next;
			q = q->next;
			if (q->next == NULL){
				p = NULL;
				q->next = r;
				r->next = NULL;
				flag = 0;
				break;
			}
		}
		if (flag){
			r->next = p;
			q->next = r;
		}

	}
}
/*	Book *p, *q;
	p = q = head_book;
	
	if(head_book == NULL){//¿ÕÁ´±í 
		head_book = new_book;
		new_book->next = NULL;
	}
	else{
		while((new_book->id > p->id) && (p->next != NULL)){
			q = p;
			p = p->next;
		}
		if(new_book->id <= p->id){
			new_book->next = p;
			if(head_book == p)
				head_book = new_book;
			else
				q->next = new_book;
		}
		else{
			p->next = new_book;
			new_book->next = NULL;
		}
	}
	return head_book;
};*/

//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise


int store_books(FILE *file, Book *head_book)
{
	if (head_book != NULL){
		Book *p = head_book->next;
		file= fopen("book.txt", "w+");
		if(file != NULL){
			while(p != NULL){
				fprintf(file, "%d\t%s\t%s\t%d\t%d\n", p->id, p->title, p->authors, p->year, p->copies);
				p = p->next;
			}
			fclose(file);
			return 0;//success
		}
		else{
			printf("Failed to open file!\n");
			return 1;//fail
		}
	}
}
//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE *file, Book *head_book){
	file = fopen("book.txt", "a+");
	Book *p;
	if(file != NULL){
		while (fscanf(file, "%d%s%s%d%d", &p->id, &p->title, &p->authors, &p->year, &p->copies) != EOF)
		{
			insert_book(head_book, p);
		}
		fclose(file);
		return 0;
	}
	else{
		printf("Failed to open file!\n");
		return 1;
	}
}







//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
void remove_book(Book *head_book)
{
	Book *p, *q;
	int b;
	p = head_book;
	q = head_book->next;
	printf("Please type in book's id that need to delete:");
	scanf("%d", &b);
	while(q != NULL){
		if (q->id == b){
			p->next = q->next;
			free(q);
			q = NULL;
		}
		else{
			p = p->next;
			q = q->next;
		}
	}
	if (p == NULL)
		printf("Invalid id\n");
}

	/*bool flag = true;
	Book *p, *q;
	p = q = head_book;
	
	while(p->id != book.id &&p->next != NULL){
		q = p;
		p = p->next;
	}
	if(p->id == book.id){
		if(p == head_book){
			head_book = p->next;
		}
		
		free(p);
		return 0;
	}
	else{
		flag = false;
		printf("Error: Cannot find this book.");
	}
	*/

//finds books with a given title.
//returns a BookArray structure, where the field "array"
// is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded 
//in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_title (const char *title, Book *head_book){
	BookArray ptr_book;
	ptr_book.length = 0;
	Book *p, *q;
	p = head_book->next;
	while(p != NULL)
	{
		if(strcmp(p->title, title) == 0){
			q->id = p->id;
			strcpy(q->title, p->title);
			strcpy(q->authors, p->authors);
			q->year = p->year;
			q->copies = p->copies;
			ptr_book.length++;
			ptr_book.array->next = p;
		}
		if(ptr_book.length > 0)
		{
			break;
		}
		else{
			p = p->next;
		}
	}
	return ptr_book;
} 


//finds books with the given authors.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_author (const char *author, Book *head_book){
	Book *p, *q;
	p = head_book->next;
	BookArray ptr_book;
	ptr_book.length = 0;
	while(p != NULL)
	{
		if(strstr(p->authors, author)){
			q->id = p->id;
			strcpy(q->title, p->title);
			strcpy(q->authors, p->authors);
			q->year = p->year;
			q->copies = p->copies;
			insert_book(ptr_book.array, q);
			ptr_book.length++;
		}
		p = p->next;
		
	}
	return ptr_book;
} 


//finds books published in the given year.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer
BookArray find_book_by_year (unsigned int year, Book *head_book){
	Book *p, *q;
	p = head_book->next;
	BookArray ptr_book;
	ptr_book.length = 0;
	while(p != NULL)
	{
		if(p->year == year){
			q->id = p->id;
			strcmp(q->title, p->title);
			strcmp(q->authors, p->authors);
			q->year = p->year;
			q->copies = p->copies;
			insert_book(ptr_book.array, q);
			ptr_book.length++;
		}
		p = p->next;
		
	}
	if(ptr_book.length == 0){
		printf("Error: There's no such book in the libiary.");
	}
	return ptr_book;
} 


void change_book(Book *head_book, int id, int change){
	Book *p, *q;
	FILE* file; 
	while (id != 0) {
		/*r->next = NULL;
		r->id = id;
		printf("Please input book's title, authors, year, copies\n");
		scanf("%s, %s, %d, %d", &r->title, &r->authors, &r->year, &r->copies);*/
		q = head_book;
		p = head_book->next;
		while (q != NULL){
			p = p->next;
			q = q->next;
			if (id == q->id){
				q->copies = q->copies + change;
				store_books(file, head_book);
				break;
			}
		}

	}
}
